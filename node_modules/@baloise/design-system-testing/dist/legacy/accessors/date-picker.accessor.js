"use strict";
/// <reference types="cypress" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatePickerAccessor = exports.DatePickerMinMaxRangeAssertableMixin = exports.DatePickerNoErrorAssertableMixin = exports.DatePickerErrorAssertableMixin = exports.DatePickerShouldHaveValueAssertableMixin = exports.DatePickerOpenableMixin = exports.DatePickerPickableMixin = exports.DatePickerWriteMixin = void 0;
var mixins_1 = require("./mixins/mixins");
var DatePickerWriteMixin = function (_a) {
    var selector = _a.selector, creator = _a.creator;
    return ({
        write: function (date) {
            cy.get(selector).type(date);
            return creator();
        },
    });
};
exports.DatePickerWriteMixin = DatePickerWriteMixin;
var DatePickerPickableMixin = function (_a) {
    var selector = _a.selector, creator = _a.creator;
    return ({
        pick: function (date) {
            if (cy.get(selector).balDatepickerIsClosed()) {
                cy.get(selector).balDatepickerToggle();
            }
            cy.get(selector).balDatepickerPick(date);
            return creator();
        },
    });
};
exports.DatePickerPickableMixin = DatePickerPickableMixin;
var DatePickerOpenableMixin = function (_a) {
    var selector = _a.selector, creator = _a.creator;
    return ({
        open: function () {
            if (cy.get(selector).balDatepickerIsClosed()) {
                cy.get(selector).balDatepickerToggle();
            }
            return creator();
        },
    });
};
exports.DatePickerOpenableMixin = DatePickerOpenableMixin;
var DatePickerShouldHaveValueAssertableMixin = function (_a) {
    var selector = _a.selector, creator = _a.creator;
    return ({
        shouldHaveValue: function (date) {
            var day = "".concat(date.getDate());
            var month = "".concat(date.getMonth() + 1);
            var pad = function (text) { return (text.length === 1 ? "0".concat(text) : text); };
            cy.get(selector).should('have.value', "".concat(pad(day), ".").concat(pad(month), ".").concat(date.getFullYear()));
            return creator();
        },
    });
};
exports.DatePickerShouldHaveValueAssertableMixin = DatePickerShouldHaveValueAssertableMixin;
/**
 * TODO: need to rework
 */
var DatePickerErrorAssertableMixin = function (_a) {
    var element = _a.element, creator = _a.creator;
    return ({
        errorCheck: function (name, error) {
            element.clear();
            var message = cy.get("cip-error[ng-reflect-control-name=".concat(name, "]"));
            message.should('contain', error);
            return creator();
        },
    });
};
exports.DatePickerErrorAssertableMixin = DatePickerErrorAssertableMixin;
/**
 * TODO: need to rework
 */
var DatePickerNoErrorAssertableMixin = function (_a) {
    var creator = _a.creator;
    return ({
        noErrorCheck: function (name) {
            var noMessage = cy.get("cip-error[ng-reflect-control-name=".concat(name, "]"));
            noMessage.should('be.empty');
            return creator();
        },
    });
};
exports.DatePickerNoErrorAssertableMixin = DatePickerNoErrorAssertableMixin;
var DatePickerMinMaxRangeAssertableMixin = function (_a) {
    var selector = _a.selector, creator = _a.creator;
    return ({
        assertDateInRange: function (date, shouldBeInRange) {
            if (shouldBeInRange === void 0) { shouldBeInRange = true; }
            if (shouldBeInRange) {
                cy.get(selector).balDatepickerIsDateInRange(date);
            }
            else {
                cy.get(selector).balDatepickerIsDateNotInRange(date);
            }
            return creator();
        },
    });
};
exports.DatePickerMinMaxRangeAssertableMixin = DatePickerMinMaxRangeAssertableMixin;
exports.DatePickerAccessor = (0, mixins_1.createAccessor)(exports.DatePickerWriteMixin, exports.DatePickerPickableMixin, exports.DatePickerShouldHaveValueAssertableMixin, exports.DatePickerErrorAssertableMixin, exports.DatePickerNoErrorAssertableMixin, exports.DatePickerMinMaxRangeAssertableMixin, exports.DatePickerOpenableMixin);
